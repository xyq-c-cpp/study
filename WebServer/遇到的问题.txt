问题一：在编写完整个服务器雏形后，对服务器进行了测试，但测试发现，浏览器发来的第一个页面请求会很快就响应，但是后续如果只有单个浏览器页面发来请求时，这时这个页面就会被卡住，一直得不到服务器的响应，只有后续再打开浏览器页面发送请求时，前一个页面的请求才会得到相应，后续的浏览器页面请求都是这种情况;
当时因为这个问题被卡住了好几天，开始我以为是epoll_wait的问题，我就百度找关于epoll_wait的开发问题，但是百度上能找到的都是关于epoll_wait如何使用，或者没有把epollfd和listenfd都设置为非阻塞而踩坑的这些情况；一直没有我想要的答案；后来找了许久，终于看到一篇博客描述的情况和我的相识，结果也确实如此。
     其实这个问题还是关于epoll_wait的，在我最初的理解是：加入epoll中的fd每有一个事件发生就报告一个事件，所以我的connect函数是只接受一个报告的fd，但事实却是：当有多个同一个端口的连接请求时，epoll加入的listenfd不管有多少个事件，都只会报告一次读事件给listenfd， 如果我们只接受一次报告的连接，那么后续的连接请求就被搁置在内核缓存区，直到有新的请求到来（不管是listenfd的还是其他已连接的fd），前面被搁置的请求才能得到处理，但是后续来到的请求还是会像之前被搁置的请求一样被搁置；解决方法就是：当listenfd事件发生时，就循环接受连接请求，直到没有连接请求。

问题二：关于线程池的编写，开始我学习到的线程池是使用pthread库提供的端口来写了的，但是在看了别人写的线程池之后就发现使用pthread提供的函数来写的话会非常麻烦，尤其是需要对任务函数和任务函数的参数进行封装，然后以这个封装来传递给pthread，这个过程非常复杂麻烦，所以我就想用简单一点的方式。因为之前看c++11特性有说到c++11提供了对多线程的支持，也就是thread库，后面就深入学习了怎么使用；
	写代码时，还是有一个很重要的点就是任务函数和任务函数参数的传递，想到了bind，但是使用还是有问题，后面学习了别人怎么使用bind封装一个任务函数和任务函数参数，就解决了，关于任务函数参数不定，就想到了c++11的变长参数模板。

    
    